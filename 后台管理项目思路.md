# 🎀day10

## 六 : 后台管理项目演示

> 准备 :开启服务器+数据库

**vue 项目学什么?**

1. 如何使用 vue 配合脚手架工具来完成一个项目
2. 学习 ElementUI 组件库的使用
3. 业务

- 3.1 登录和退出
- 3.2 用户+角色+授权+菜单
- 3.3 商品模块;



## 七 : 开启本地服务器

**画图 :** 接口访问路径 :
前端页面 ===> 接口服务器 ===> 数据库服务器 ==> 数据库

### 第一小步 : 打开 : 数据库服务器

> 打开 `phpStudy` ,点击`启动`

### 第二小步 : 导入数据库

1. 打开 `navicat`

2. 点击`连接` : 创建一个`MySQL`连接

3. 用户名和密码 : root-root(不能乱写) 这个是和 config 里的配置一样的

4. 创建一个数据库 : `shop_admin` 不要乱写, 选择倒数找到 unt-8

5. 双击打开数据库

6. 导入 `sql语句` => 右键运行 SQL 文件 => shop-api 最后一个 sql 文件

   > 如果没有反应 : 表 => 右键刷新

### 🙃第三小步 : 开启接口服务器

1. 打开 `shop-api`
2. 运行 `npm start`
3. 显示成功 : `API 接口服务启动成功，占用端口 8888`

### 第四小步 : 测试接口

```js
http://localhost:8888/api/private/v1/login?username=admin&password=123456

项目使用接口 : (记得保存)
// shop-api里面有
```

### 第五小步 : 使用

- 每天做项目之前 :
- 1. 每次都要先开启 `phpStudy` 中的 `mySql`
- 1. 每次都要打开`shop-api` , 运行 `npm start`



## 八 : ES6的模块语法 (基于webpack基类演示)

## 8.1 :  export default 默认导出一个模块 ( 简单类型 + 复杂类型 )

### 导出 : export default

```js
#  
# 默认 只能`导出一个`
let str = 'abc'
let num = 20;
let obj = { name :'zs' }

export default num
// export default obj
```



### 引入 : import

```js
# 导入的名字可以任意
import res from './a.js'
console.log(res)
```


## 8.2  export 导出多个模块, 都放在一个对象里

### 导出 :  export 

- ```js
  // 逻辑模块 
  // 登录一个函数
  export let login = () =>  {
    console.log('登录');
  }
  // 注册一个函数
  export let register = () =>  {
    console.log('注册');
  }
  
  ```




### 导入 : import   解构

```js
 # 方式1
import * as res from './a'
console.log(res);
res.login()
res.register()
#### 方式2
import { login, register as reg } from './a'
login()
register()
```
#### 8.3 import 模块

```js
import axios from 'axios';
```



# 项目思路

#### 一.初始化vue项目

打开powershell窗口:输入vue init webpack shop_admin

清除不要动东西(logo和hello world组件)

#### 二.手动配置路由

```js
安装:npm i vue-router;

在src文件夹下创建一个router文件夹 ,下面建一个router.js

路由的准备工作:

1.引入 import VueRouter from 'vue-router'

2.实例化 const router = new VueRouter( )

3.导出路由  export default router;

之后在main.js中引入路由;

引入之后并且挂载（注意：写在main.js里的el:'#app'下面;）；


# 注意:
vue-router 和vuex 在模块化(把他们单独提到一个js文件里)工程中,记得`需要使用vue 安装一下路由功能`;

1.先在router.js中引入 import Vue form 'vue' ;

2.再在router.js中安装 Vue.use(VueRouter);

3.并且在main.js中引入路由;并挂载;

```



#### 三:创建两个子组件并且配置路由

**创建组件**: 

```
components文件夹下创建：

在login文件下建一个login.vue;

在 Home文件夹下建一个home.vue;

```



##### 在router.js里

1.**入口**:  url手动写

2.**规则**:

```js
routes:[
	{path...},    //重定向
    {path:'/login', component:Login},
    {path:'/home', component:Home}
    
]
```



3.**组件:**把分组件引入即可

4.**出口**:放在根组件App.vue根组件里面写;

### Element-ui组件库:

是一个基于vue2.0版本的组件库;

**安装**: npm i  element-ui -S  (-D开发阶段需要,发布阶段不需要);

**引入element**:在main.js中 

import ElementUI from 'element-ui';

..css

注意:也需要安装一下Vue.use(Element.ui)

template里面只能有一个根元素 ;



**login登陆页:**

**在组件库里找一个表单组件:**

1.拷贝结构放在login.vue里的template模板里;

2.拷贝js放在login.vue里的script里面;

注意:

` prop = 'username'`是在后面校验rule用到的;



五:表单

### 六:发送请求 登陆

接口(本地服务器)

请求工具:axios

​	安装:

​	引入:

​	使用: 接口地址路径需要在前面拼接基准地址:

```js
axios.post('http://localhost:8888/api/private/v1/login',this.ruleForm)
        .then(res => {
          console.log(res);
          if(res.data.meta.status===200) {
             //1. 登录成功提示
              this.$message({
                message: res.data.meta.msg,
                type: "success",
                duration: 800
              });
              //2. 跳转到home页面 (编程式导航)
              this.$router.push('/home')
          }
        })
      })
```





```js
# 提示信息:
当点击登陆之后，显示提示信息 并且跳转到home页面;

this.$message({
                message: res.data.meta.msg,
                type: "success",
                duration: 800
              });

```



#### 七.跳转:

```js
# 声明式导航:
<router-link to='/home'></router-link>
在`组件,标签里`使用
```



```js
#  编程式导航:
this.$router.push('路径'）
在`事件里`使用;
```



### 八.$route 和$router

```js
# $route:
路由对象,包含url信息,解析
后面的哈希路径;有一些参数  query path params 属性;
例如：
获取参数：this.$route.params.id  #（见笔记day07）


# $router:
路由实例 编程式导航(跳转),登陆拦截(导航守卫);
this.$router.push('路径'）
```



#### 处理登陆 页面垂直居中:

` <el-row :span='8'>`行

` <el-col>`列

**注意:**

#### 表单样式和背景颜色:



#### home页面:

在文档里找一个布局容器:

复制代码,分析:









## es6的模块化语法:

##### 1.export default 和import

**注意点**:使用export default只能导出一个

```js

```



##### 2.export 和 import

**注意**:export导出需要导出的是整体;

```js
导出:export let register = () => {

	console.log('注册')

}

导入:import { register , .......,....... } from './a.js'
如果要取别名还可以register as a  名字就改为了a

注意:使用export可以导出多个数据,这些数据都放到了一个对象里面,名字默认不要乱写;

外面开发还有一种用法:方式二

import * as 别名 from './a.js'

调用的时候:别名.函数名( )

例如:MG.login( )

```

##### 3.import axios form  'axios'

从`node_modules`里面拿到`axios`这个模块;





# 🎀day11

#### 各组件间的样式会相互影响的解决办法:

1.在样式标签加scoped属性可以限制css只在当前组件的标签起效果;` <style scpoed>` 

2.但是:添加scoped之后,标签之外的样式会失效;可以把标签外的样式拉出来重写放在一个新的` <style>`里面;

3.login.vue和home.vue样式重复的部分,都剪切走,在main.js里引入一个全局的css;在assets文件夹下创建一个common.css文件, 把刚刚剪切的html,body,m0,p0等一些样式放进去;

#### 二:把代码上传到码云:

1.git 管理我们的代码: 终点输入 git init;

2.查看状态:git status   显示红色

3.代码从 工作区 ==> 暂存区  git add .   显示绿色

4.代码从 暂存区 ==> 本地仓库 git commit -m +提交信息说明;

5.本地仓库=>上传码云;

登陆马云,创建仓库;关联地址,以后可以直接操作origin

git push -u origin master (第一次上传),以后上传都是master分支

以后上传都是get push 就好了

#### 三:登陆状态的判断说明

### 问题1:判断是否登陆过?

```js
# 需求:不登陆,不允许访问其他页面;

# 问题1:判断是否登陆过?

登陆成功后,后台会返回给我们一个token令牌,我们`保存到本地`,要判断是否登陆,我们就从本地获取这个令牌,如果有值==>登陆过,没有==>就没有登陆过;

如何从后台动态数据拿到token:res=>data=>data=>token;
在login.vue页面登陆成功的的里面，保存token：`localStorage.setItem('token',res.data.data.token)`

```



#### 问题2:如果没有登陆过,地址栏输入访问其他页面,我们需要做些什么?

```js
判断访问的地址是:（`利用导航守卫`）
1.登陆页面=>可以访问;
2.不是登陆页面=>判断是否登陆过=>没有登陆==>定义跳到登陆页面;
登陆过=> 可以直接访问其他页面;

```

​	

### 四:导航守卫

```js
概念:通过跳转/取消的方式,守卫登陆页面是否登陆过，是否可以跳转访问其他页面;
在vue官网，vueRouter里，有导航守卫文档；`导航守卫是vue-Router提供的`；
网站：https://router.vuejs.org/zh/guide/advanced/navigation-guards.html

在route.js routte写:
每个守卫方法接收`三个参数`：

to: Route: 即将要进入的目标 路由对象

from: Route: 当前导航正要离开的路由

next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。

		next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。

		next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。

		next('/') 或者 next({ path: '/' }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: 'home' 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。

		next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。

```

####  

#### 全局前置守卫

```js
# 全局前置守卫:

`在route.js里`  route实例下面写:

router.beforeEach((to,from,next)=>{
    //to 要跳转的目标对象
    //from 从哪里跳转过来的
    //next 是个函数 里面可以写跳转到的页面路径
	next( ) ==> 放你走
    next(fasel)==>取消
    next('/') ==>跳转,指定跳转的路径
    
})

//实例代码
router.beforeEach((to, from, next) => {
  if (to.path === '/login') {
    next()
  } else {
    // 说明是其他页面,需要判断是否登陆
    let token = localStorage.getItem('token')
    token ? next() : next('/login')
  }
})

```





### 处理使用less编译时候报波浪线错误的问题:

### 

```js
在Home.vue页面，
# 处理使用less编译时候报波浪线错误的问题:

如果使用less格式写样式，需要在<style>里面写一个lang='less'

安装 ： less-loader 和  less:  npm i less-loader 和 less;

```





#### 六:退出功能logout()

```js
home.vue里,
给点击按钮注册点击事件,并且控制默认跳转行为;

element文档找到提示框的功能代码

点击确认按钮:以后工作中,需要发送至后台:上课中,不用;

	1.删除token

	 localStorage.removeItem('token')

	2.跳转到login

	this.$router.push('/login')

	3.提示退出成功

点击取消按钮: .catch ( )

```



#### 七:左侧菜单栏

```js
element中#NavMenu导航菜单:

拷贝代码到home.vue

# 分析：

 - 	<el-menu > 菜单父组件:
 - 	<el-submenu>: 菜单子组件(# 可以展开,里面可以放el-meny-item 菜单元素)
 - 	<el-meny-item >菜单元素  #不能展开
-    default-active='2'  默认第2个高亮,点击的时候,点哪个哪个高亮;
- @open="handleOpen"
- @close="handleClose" 监听打开与关闭 
- background-color背景色 
- active-text-color高亮颜色 
- #  slot="title"具名 负责显示标题
- <template>在这里是一个虚拟的标签，为了把选项包裹在一起；
- index= '1-1' , index= '2-1' , index= '2-2'
```





#### 八 （重要）给导航添加路由的功能

```js
# 点击侧边栏导航，地址栏的路径发生改变并且main部分改变为相应的组件;

# 组件里的router `属性` ：默认为false，改为true 就会启动路由功能；以index作为path进行路由跳转；
router:=>false => true 启动路由功能;
注意：
`   :router = 'true'  `  ,'true' 必须是个字符串；
-以index作为path进行路由跳转

在导航菜单插件的el-menu里面添加:router='true'

# index='点击的路径栏设置的对应的名字'users/roles/rights

```



##### 

```js
# 匹配users/roles/rights几个路由组件:
1.创建组件Users.vue/Roles.vue  /Right.vue

在src的components里建一个文件夹users,下建一个Users.vue ..... roles/Roles.vue   rights/Right.vue

2.走流程

	2.1入口(点击地址栏显示的#后面的内容)

	2.2匹配规则 在route.js里面写；
     `
routes: [
    {path: '/', redirect: '/login'},
    {path: '/login', component: Login},
    {path: '/home', component: Home},
    {path: '/users', component: Users},
    {path: '/roles', component: Roles},
    {path: '/rights', component: Rights}
  ]
	`

	2.3组件 在router.js.里引入已经创建好的组件;
`
import Users from '../components/users/Users.vue'
import Roles from '../components/roles/Roles.vue'
import Rights from '../components/rights/Rights.vue'
	
`
 # 2.4出口 在App.vue里   这里用到嵌套路由

	
	# 嵌套路由:是路由里面的路由

	# 注意:
     users/roles/rights是home的子路由,需要写在这三个组件要放在home组件里面,
     # 在home.vue中main部分里面留一个占位置的出口;<router-view></router-view>

```



#### 路由规则:

```js
routes: [
    { path: '/', redirect: '/login' },
    { path: '/login', component: Login },
    {
      path: '/home',
      component: Home,
      children: [
        { path: '/users', component: Users },
        { path: '/roles', component: Roles },
        { path: '/rights', component: Rights }
      ]
    }
  ]
```



#### users.vue组件:

```js
# 分析
<!-- <el-table>表格组件 -->
<!-- <el-table-column>表格的列 -->
<!-- prop="username" 是读取的date里的数据 -->
<!-- :data="tableData" 是一个数组 -->
<!-- 组件只包含表格的列 ，行由数据决定 -->

export default {
  data() {
    return {
      tableData: [
        {
          username: "王小虎",
          email: "780023683@qq.com",
          mobile: "15702970902"
        },
     
      ]
    };
  }
};

发送axiso请求

```



```js
created() {
    loadUserList()
  },
 methods:{
    // 加载用户数据
    loadUserList() {

    }
  }
# 在method里发送请求，在created生命周期里调用，自动加载数据；
```



### 发送axios请求

```js

# 发送axiso请求
安装axios
引入axios在users.vue里；

在created() {
	this.loadUsersList()
}，
methods:{
//加载用户数据
loadUserList() {
    。。。
}
# 这次请求返回无效的token，因为每次发送请求，都要携带token；
# 注意:🙃必须在请求头中使用 Authorization 字段提供 token 令牌

😋登陆之后,每一次发送请求都需要携带token令牌;之前的保存到本地是让我们本地指定是否登陆成功,但是后台服务器不知道;需要告诉后台;
# 需要在发送请求中加一个请求头
headers:{
Authorization:localStorage.getItem('token')
}



```



```js
# 注意:请求用户列表数据需要传入参数，因为是get请求，所以直接在路径后加params；

loadUserList() {
        axios.get('http://localhost:8888/api/private/v1/users',
       {  params: {
            query:"",
            pagenum:1,
            pagesize:6
       },
          headers: {Authorization:localStorage.getItem('token')
        }
       })
.then(res => {
          console.log(res)
      })
  }

# 最后，把请求到的数据赋值给userList;
this.tableData = res.data.data.users
```





### users.vue分页功能

```js
文档里带有背景色的分页:用一个div把数据和分页包起来;

分析代码:
background 背景
layout="prev, pager, next"  布局

:total  总页数 需要动态绑定 :total='total';发送请求获取的数据总个数就是total:
# 注意： 需要先在data里申明定义一下  后赋值;

page-size:每页显示的数据条数；文档里面的page-size属性`默认每页显示10条数据`,需要在html里`定义一下`属性:page-size='2'

pagenum:当前页:默认1

# 注意：
用 pagenum先在data里`定义一下`,之后根据请求到的数据动态获取并且绑定到:current-page='pagenum',这个默认是当前页是1,需要动态绑定;

```



## day12

### 一:分页效果

##### 点击分页在users.vue页面:

```js

给组件<el-pagination>添加一个@current-change="changePage" 事件, currentPage 是当前点击的页数, 点击页码改变时会触发,回调参数 是当前页;@current-change=''
```





```js
//改变页数;

changePage(curPage )  {

this.loadUsersList(curPage)

}
```



```js
形参:pagenum ,是由前端传给后台的;

在es6语法里pagenum = 1 意思是如果前端传值了,pagenum就是前端传过来的值,如果前端没有传,就 pagenum = 1 ;

# 调用this.loadUsersList(curPage)函数传入点击的当前curPage页码;

# 页面一进来就执行created( )钩子里的函数, 默认第一次获取到的是第1页的数据,让loadUsersList(  1  ),后面再根据点击的页码传递对应的页码数据过去;

```



### 加入文本输入框-element插件

```js
放在users.vue表格的上面

拷贝代码分析:v-model= searchText

# 查询内容searchText定义为空,  searchText :' '

slot='append':决定搜索按钮的位置  append放在后面 ,prepend放在前面 ;

```



#### 添加用户 的按钮组件

````js
紧挨着放下面:

放成一行两列的结构 8/3

行:el-row  列:el-col

gutter属性:指定每一栏直接的间隔;加给row :gutter='20'

````



#### 输入框 输入内容搜索对应数据

```js
# 给查询按钮注册点击事件 @click="startQuery"
```





```js
查询到数据之后,首先让他显示查询到的第一页数据；
// 开始查询
	startQuery() {
        console.log(this.searchText);
        // 获取查询内容的第一页数据
        this.loadUsersList(1, this.searchText);
    }
    当查询到的数据超过一页，还需要点击查询到数据的第二页数据的时候,`还需要把查询内容的参数也传递过去,在改变页数的方法里;`

// 改变页数
    changePage(curPage) {
      console.log("改变", curPage);
      // 把取到的curPage赋值给pagenum,重新渲染页面;
      this.loadUsersList(curPage,this.searchText);
    },
```



### 面包屑导航(图标分隔符)

```
放在users.vue里

背景色:

高度:40px 

垂直居中:40px

padding-left:20px

表格的列

正常列:能够赋值文本(字符串)/数组;通过porp赋值

自定义列:其他标签/组件/需要处理的文本或者文字

```



#### 表格里操作栏数据:

```
element插件table表格自定义列模板:

button按钮 <el-button>...</el-button>

plain:镂空样式

size:mini   迷你型

type='primary'/danger/warning  颜色

```





## promise语法





```js
# promise是es6提出来的一个语法:
作用:想以编写同步代码的方式处理异步的一种解决方案;

以前处理异步 都是通过回调处理的 ;
setTimeout(function(){
   
   },1000)
   $.ajax({
     url : '..',
     type : '',
     data : '',
     success : function(res){
  
    }
   })

//这种处理方法,如果异步比较简单,次数比较少的话,都是可以的,但是如果次数比较多,异步比较复杂,就会出现一个回调地狱的问题

  * 1. 代码不优雅  2-结构不清晰  3-处理起来不方便

```





```js
$.ajax({
  url: '',
  type: '',
  data: '',
  success: function (res) {
    
    // 此处省略100行
    // 第一次请求成功之后,再请求第二次
    // 第二次请求
    $.ajax({
      url: '',
      type: '',
      data: '',
      success: function() {
         // 第三次请求
        $.ajax({
          url: '',
          type: '',
          data: '',
          success: function () {
            
            // 第四次请求
            $.ajax({
              url: '',
              type: '',
              data: '',
              success: function() {
                
              }
            }) 
            
          }
        }) 
      }
    }) 
    
  }
}) 
```



#### 使用promise解决回调地狱的问题:

```js
1.Promise是一个构造函数;
实例化构造函数const p = new Promise()

2.()里面是一个回调函数;

回调里面有两个参数:

resolve :fn() { }  异步操作成功后调用resolve()

reject: fn() { }  异步操作失败后调用reject()

3.promise里面一般放一个异步操作

🙃注意:p是一个promise类型;axios.get也是一个promise类型,所以也可以 p.then();
	   aixos.get('...').then()发送的请求,也是promise类型;
	   XXXX.then()  XXX就是一个promise类型;

```

```js
const p = new Promise((resolve, reject) => { 
  
  setTimeout(() => {
    console.log('异步操作开始了');

    # 1.假设异步操作成功 => 调用 resolve  ==> 会执行then 里面的回调也就是说xxx.then是在resovle调用成功之后执行的;resolve括号可以传参,传递的参数在.then里面可以接收,打印
    resolve('操作成功哦也')

    # 2.假设异步操作失败 ==> 调用 reject  => 执行 catch 里面的回调
    // reject('操作失败了,灰常可惜..')
  }, 0);
})  
```



```js

异步操作成功调用then
异步操作失败会调用catch,执行catch里面的回调;
p.catch(err=>{
    log('操作失败了')
})
```







使用promise封装一个异步读取文件1

使用promise封装一个异步读取文件2

### async和await是es8提出来的语法;

```js
也是想通过编写同步代码的方式处理异步,但是处理的更彻底;

 async : #修饰一个函数(内部有异步操作的函数 )
 格式     async function test(){    }
 await : # 修饰一个异步操作 (promise实例 ) 
 格式   await 异步操作(promise实例)

 #注意点1
 : async 和 await 成对出现+
     6
 #注意点2
 : async 和 await 处理处理读取失败的情况下要配合 try...catch ... 
 #注意点3 
 : async 一定要加在 await 最近的函数上面
 
```

配合try...catch处理读取失败的情况

```js
不放在try...catch里,会影响后面异步的执行;
async function fn () {
  
 try {
    // 读取a文件
    let a = await ml_readF("./a1.txt");
    console.log(a);
  } catch (error) {
    console.log("这里出错了,我要做其他的处理......比如说删除某个女朋友");
  }

  // 读取 b 文件
  let b = await ml_readF("./b.txt");
  console.log(b);

  // 读取 c 文件
  let c = await ml_readF("./c.txt");
  console.log(c);
}

fn();
```







promise的其他两个用法;

**promise的三个状态:**

​	pending:进行中(等待)

​	resolved:成功操作;

​	rejected:失败操作;

#### 改造项目





#### 抽离三个部分

建一个Users.html,把users.vue的html剪切走 并且通过src引入` <template src=''></template>`

建一个Users.js,把users.vue的js剪切走 ,并且通过src引入

建一个Users.less,把users.vue的style剪切走 ,并且通过src引入



#### 插槽slot

作用:替换内容,分发内容;

基本使用:

`<el-car>...</el-car>`

```js
<div id="app">
      		<!-- 第一次使用组件 -->
      <el-car>
        <div>大众发动机</div>
      </el-car>
      		<!-- 第二次使用组件  -->
      <el-car>
        <p>奥迪发动机</p>
      </el-car>
     		 <!-- 第三次使用组件  -->
      <el-car></el-car>
    </div>
    <script src="./vue.js"></script>
    <script>
      //  注册组件
      Vue.component('el-car', {
        template: `
     <div>
        <h3>提示</h3>
        <slot>
          
        </slot>
        <button>取消</button>
        <button>确定</button>
     </div>
      `
      });

      const vm = new Vue({
        el: '#app',
        data: {}
      });
</script>
```



# day13

#### 具名

```js
<div id="app"> 
     <!--
    第一次使用
    <el-car>
      <h3 slot='n1'>大众提示</h3>
      <div slot='n2'>大众发动机</div>
    </el-car>


  第二次使用 
    <el-car>
      <h3 slot='n1'>奥迪提示</h3>
      <p slot='n2'>奥迪发动机</p>
    </el-car> -->

</div>

<script src="./vue.js"></script>
<script>
Vue.component('el-car',{
     template:`
     <div>
        <slot name='n1'></slot>
        <slot name='n2'></slot>
        <button>取消</button>
        <button>确定</button>
     </div>
      `
    }) 
</script>

```



#### 使用具名决定位置

```
 <!-- append 后面 prepend 前面 -->
 <div>  <slot name='prepend'></slot> <input type='text' >  <slot name='append'></slot>  </div>
      
```



#### 😋作用域插槽

注意:

```js
1.组件el-car内的子元素<p></p>想访问el-car里面的数据==> 直接访问是不行的==>需要通过属性赋值给<slot :type='type' :row='row'></slot>
    
2.slot-scope='scope'  以上属性都将成为scope的属性  scope.type 
```



方式二:也可以加在template上面

```js
注意:vue2.6之后,作用域插槽必须要使用<template></template>

🙃通过template可以scope.row拿到他的对象里的数据;

```



```js
<div id="app">
    <el-car>
      <!-- 方式1 -->
      <!-- <p slot-scope="scope">大众发动机型号 : {{ scope.row.name }} {{ scope.row.age }} </p> -->
    
      <!-- vue 2.6.0 之后,必须要使用 template  -->
      <!-- 方式2 -->
      <template  slot-scope="scope">
        <p>大众发动机型号 : {{ scope.row.name }} {{ scope.row.mg_state }} </p>
      </template>
    </el-car>


           
 </div>
   <script src="./vue.js"></script>
   <script>

    Vue.component('el-car',{
     template:`
     <div>
       <h3>提示</h3>
        <slot  :row='row'   :type='type' num=890 ></slot>
        <button>取消</button>
        <button>确定 </button>
     </div>
      `,
      data() {
        return {
          type :'EA888',
          row : {
            name : 'zs',
            age : 18,
            mg_state : true
          }
        }
      },
    }) 

   const vm = new Vue({
      el: '#app',
      data: {
         
       }
    })

    </script>
```



![](E:\笔记整理\14-vue\images\scope.png)



### users.html页面用户状态的添加

```js
页面样式:
element插件Switch 开关里找到对应的;

html样式要写在template标签里面;并且给标签加上slot-scope='scope' 属性;

#注意
:v-model绑定状态,要绑定`当前对象`的用户状态;

# scope.row拿到的是点击的当前行的对象;
再 .mg_state才是用户状态,所以

v-model = 'scope.row.mg_state' 用户状态 : true / false

mg_states是动态请求到的数据属性;

#注意:
在自定义列里面`不能直接`绑定动态获取的data里面的数据;需要用到template自定义属性slot-scope='scope'.再通过scope.row...获取

```



🙃如果页面中标签被template包裹**通过template的scope.row属性可以拿到他的对象里的数据**;

##### 自定义列获取数据:

```
<template slot-scope='scope'>			{{scope.row.mg_states}}
</template>
```



**给后台发送请求**,通过后台数据修改用户状态

html页面中,@change= 'changeState (scope.row)'

**users.js里面**,接收row,打印row,可以可以拿到对应点击的那个对象的id和mg_state状态;

接口参考1.3.3   修改用户状态

**重要:put发送请求,里面有3个参数:(url地址,请求的参数,配置项),当第二个请求参数没有的时候,需要写个null,配置项不能是第二个参数;**

```js

```



### 解决axios的几个问题

```js
1.每次都添加基路径

2.每个js文件豆要引入aixos

3.每次豆要携带token

```



##### 在main,js里处理axios的三个问题

注意要先引入axios;

1.基路径:axios.defaults.baseURL = 'http://localhost:8888/api/pribate/vi/'

```js
2.把axios赋值到vue原型:Vue.phototype.$axios = axios

在users.js等页面的使用:把axios改成this.$axios

```



3.解决方法1:在main.js等页面加axios.defaults.headers.common['Authorization] = localStorage.getItem('token);

解决方法2:拦截器Interceptors

添加一个请求的拦截器在main.js:

```js
axios.interceptors.request.use(
  function (config) {
    // 拦截每次请求,携带token
    config.headers.Authorization = localStorage.getItem('token')

    return config
  },
  function (error) {
    // Do something with request error
    return Promise.reject(error)
  }
)

```



### 删除用户

注册点击事件@click='delUser(scope.row.id)'

参考接口  1.3.6

在users.js里;使用asnyc 和 await   配合try ...cahch ...使用;

```js
async delUser(id) {
      try {
        //点击弹出一个确认窗口
        await this.$confirm('此操作将永久删除该用户, 是否继续?', '提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning'
        })
        let res = await this.$axios.delete('users/' + id)
        if (res.data.meta.status === 200) {
          this.$message({
            type: 'success',
            message: '删除成功!',
            durnation: 800
          })
          // 重新刷新列表数据
          this.loadUsersList()
        }
      } catch (error) {
        this.$message({
          type: 'info',
          message: '已取消删除',
          durnation: 800
        })
      }
    }
```



### 添加用户

#### 弹框

插件<el-dialog>Dialog 对话框==>自定义内容

给<el-dialog>加宽度 label-width=100px;

**接口1.3.2**

显示用户对话框的默认值提前定义一下:

​     dialogAddUserVisible: false

定义一下添加用户表单对象:

form : {   }

注意:点击确认或者取消按钮都是隐藏对话框;

注意:addUsersForm,双向绑定,在users.js提前写好,保证正常绑定:写上属性,内容为空就好;



#### 校验规则

1.在users.html里给el-form 表单添加rules属性` :rules='rules'`

2.每一项都得有个prop,比如prop= 'username'

**3.**在users.js data数据里定义校验规则  

```js
   // 校验规则
      rules: {
        username: [
          // 如果文本不写内容会触发
          { required: true, message: '请输入用户名', trigger: 'blur' },
          // 格式不正确会 触发
          { min: 3, max: 5, message: '长度在 3 到 5 个字符', trigger: 'blur' }
        ],
        password: [
          // 如果文本不写内容会触发
          { required: true, message: '请输入密码', trigger: 'blur' },
          // 格式不正确会 触发
          { min: 6, max: 10, message: '长度在 6 到 10 个字符', trigger: 'blur' }
        ],
        email: [
          // 格式不正确会 触发
          {
            pattern: /^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$/,
            message: '邮箱格式不正确',
            trigger: 'blur'
          }
        ],
        mobile: [
          // 格式不正确会 触发
          {
            pattern: /^1([38][0-9]|4[579]|5[0-3,5-9]|6[6]|7[0135678]|9[89])\d{8}$/,
            message: '手机格式不正确',
            trigger: 'blur'
          }
        ]
      }
```



注意:邮箱和手机格式需要匹配正则;

给添加用户按钮注册点击事件,点击弹出对话框;@click=showAddUserDialog

在uses.js里,显示 添加用户的对话框

 ```js
 showAddUserDialog( ) {

      this.dialogAddUserVisible = true

  },

 ```



#### 添加用户信息

搜集输入的信息:

确认按钮@click='addUser'

在users.js里

```js
async addUser() {
      let res = await this.$axios.post('users', this.addUserForm)
      //🙃注意:这里需要拼接的4个参数,前面定义的时候已经放在了addUserForm这个对象里,所以也可以直接使用addUserForm;
      console.log(res)
      if (res.data.meta.status === 201) {
        // 1. 关闭对话框
        this.dialogAddUserVisible = false
        // 2. 提示添加成功
        this.$message({
          message: '添加用户 成功',
          type: 'success',
          duration: 800
        })
        // 3. 刷新列表
        this.loadUsersList()
      }
    }
```



创建成功的状态码是201

##### 1.关闭对话框

##### 2.提示添加成功信息同时关闭对话框时候清空数据框数据

**对话框关闭的事件**,是element提供的;@close事件='addUserDialogClose'

//users.js拿到表单并且重置;

拿到表单;在users.html里el-form 标签上加上 ref="addUserRef" 

 this.$refs.addUserRef.resetFields() 

**resetFields()** 是element里提供的表单重置的方法 

##### 3.刷新列表数据



### 编辑用户操作

1.点击弹出编辑用户对话框

在html编辑按钮的标签上注册点击事件;

@click="showEditUserDialog(scope.row)" 

在users.html里,

```js
:visible.sync='dialogEditUserVisible '

```



用户名改为一个` <el-tag>`   标签,因为不需要修改用户名所以直接把input换掉;        

```html
<el-tag type="info">{{ editUserForm.username }}</el-tag>
```

​                                                                                                                                                                                                                                                                                                                                                                            

2.展示点击的那个目前已经有的信息

注意:应该提前给一个默认的弹出框状态和添加时候表单对象的格式;

**注意:**用户名是不需要被修改的;

```js
	//显示用户对话框的默认值
      dialogAddUserVisible: false,
      //添加用户表单对象
      addUserForm: {
        username: '',
        password: '',
        email: '',
        mobile: ''
      },
```



当点击编辑按钮的时候就应该拿到scope.row,把数据对象传过来;并且赋值到编辑框;

```js
// 点击编辑按钮 显示编辑用户的对话框
    showEditUserDialog(row) {
      const { username, email, mobile, id } = row
      this.editUserForm.username = username
      this.editUserForm.email = email
      this.editUserForm.mobile = mobile
      this.editUserForm.id = id

      this.dialogEditUserVisible = true
    },
```



3.更改后点击确定把更改后的数据发送给后台,更新后台数据

接口1.3.5

**编辑用户**:

编辑完成显示当前页(this.pagenum)







# day14

### 权限列表页面Rights.vue

获取所有的权限,获取所有的角色,绑定权限和角色的对应关系;

用到表格组件;

`<el-table :data="rightsList" >`

权限名称:     prop='authName'

路径:      prop='path'

等级:     prop='level'

在methods里写:

```js
loadRightsList( ) {

let res = this.$axios.get('rights/list')

}
注意:要在一进入页面的时候在钩子函数created里面调用一次loadRightsList( )
```

#### 索引

插件里找表格里的自定义索引,自定义 `type=index` 列的行号。 ` <el-table-colum>`

type='index;  这个index是从1开始的;

:index=indexMethod( ) ;这个:index是从0开始的;

处理索引;注意点:返回一个参数; index 从0开始

index事件: 

```js
indexMethod( index) {

	return index;这个index就是从0开始的
}

```



#### 处理等级:

写在`<template slot-scope='scope'>` 标签里,使用自定义列处理;里面放三个` <span>`标签;

v-if = 'scope.row.level == 0'  显示一级;

v-elseif = 'scope.row.level == 1'  显示二级;

v-else = 'scope.row.level == 2'  显示三级;

```js
<template slot-scope="scope">
   <span v-if="scope.row.level == 0">一级</span>
   <span v-else-if="scope.row.level == 1">二级</span>
   <span v-else>三级</span>
</template>
```



#### 面包屑导航

.bread



## es5语法:解构

```js
let obj = {
  name: 'zs',
  age: 20,
  sex: '女神',
  height : 165  
}

test(obj)

//解构用法
function test (obj) {
  
  // let name = obj.name;
  // let height = obj.height
  // let sex = obj.sex

  const { name, height , sex:ff } = obj

  console.log(name,height,ff);
  
}

```





## 角色列表roles

抽离成三个部分:

Roles.js

Roles.html

Roles.less

通过src引入在Roles.vue里;

在组件里找到表格模板;

接口1.4.3 get方法

角色名称:      prop='roleName'

描述:      prop='roleDesc'

:data='rolesList'

1.发送请求,加载左边角色列表的数据 

```js
async loadRolesList () {
      let res = await this.$axios.get('roles')
      console.log(res)
      this.rolesList = res.data.data
    },
```



#### 第一列索引

...同之前的方法;

发送请求,动态获取角色列表数据;

把数据赋值给rolesList之后,会报错 说rowKey is required, 告诉我们的需求和版本不能匹配,所以需要

element-ui重新安装成2.4.11版本;npm i element-ui@2.4.11

##### 在element-ui插件table表格=>找到展开行

在roles.html;注意要加template标签;

根据动态请求回来的数据确定一共有几行几列;

#### 角色列表=>展开行显示权限(左侧)

根据children的个数创建5行` <el-row>`

再创建2列` <el-col>`,左边占4,右边占20;

一共3层

##### 第一层  class="row1" 

` <el-row  v-for = 'item1 in scope.row.childern' :key= 'item1.id'></el-row>`

##### 第二层  class="row2" 

在第一层的第二列里写;

##### 第三层    class="tag" 

在第二层的第二列里写;

给每层的row取一个class类名;

注意:每一个` el-tag`标签使用的是直接在插件里找de 可移除标签,不是在后面加的X图标;

**closable属性**可以定义一个标签是否可移除 

箭头:一个i标签; 字体图标  注意:要写在el-tag标签的外面;

#### 分配权限(右边)

##### 1.点击右侧,弹出一个对话框;

-找一个模板 =>树形控件=>默认展开和默认选中 修改修改在roles.html

-默认一进入页面数据树是隐藏的;

```js
// 是否显示分配权限对话框

dialogAssignRightsVisible: false,

```

roles.html里面,` el-dialog  `   :visible.sync='dialogAssignRightsVisible';



**组件里的树形控件:默认展开和默认选中**;

树的数据:data 数据

show-checkbox 是否展示多选框;

:default-expanded-keys=[2,3] 默认展开;

半选中;

##### 2.展示所有的权限数据

进入页面在created() {｝钩子函数里调用一下;

加载权限类别数据loadRightsList( ) {

接口:1.4.1 get请求;

}

```js
defaultProps: {
     // children : 结构
     children: 'children',
     // label : 显示名称
     label: 'authName'
}
```



##### 3.展示已有的权限

参考:树节点的选择,通过key设置;

显示已经拥有的权限;

这里有个dom异步更新的问题;

只需要给第三层的id设置状态就可以了

3.2获取当前角色的第三层id;所以在@点击的时候就需要把对象传过去了;

从第一层遍历到第三层;

##### 4.发送请求,分配权限;

需要两个参数: roleId =>点击的时候,因为可以拿到row对象,所有可以拿到roleId

rids=>所有的权限id 

​	@click='showAssignRIght( )'

​	需要拿到点击的那个的id,所以需要提前存一下;

rids是所有的权限id,包括半选的和全选的;模板里帮我们提供了对应的方法获取;

半选 getHalfCheckedKeys( );

全选  getCheckedKeys( )

rids  :keys.join(' , ')         转化成用逗号分隔的字符串形式;

==200的时候隐藏对话框

提示更新成功;

刷新页面列表数据:

this.loadRolesList( )



### users用户列表页面给用户分配角色

##### 1.点击按钮弹出对话框

插件==>Dialog对话框==>自定义内容

:visible.sync='dialogAssignRoleVisible'

在users.js里,在data数据里设置

```js
 // 分配角色 : 是否显示分配角色对话框  false 不显示
  dialogAssignRoleVisible: false,
```

// 给html里的表单取名`<el-form :model="assignRoleForm" >`

// js里.默认先给assignRoleForm表单内容一个空对象{ }

// 给form设置宽度 label-width="80px"

用户名后面是tag标签,所以把input删除换成tag标签;

```js
<el-tag>{{assignRoleForm.username}}</el-tag>
//assignRoleForm.username 是从js中分配角色表单对象中获取的
	🙃// 分配角色表单对象
      assignRoleForm: {
        username:'测试',
      }

```



```js
<el-select v-model="assignRoleForm.rid" placeholder="请选择角色">
     <el-option label="区域一" value="shanghai"></el-option>
</el-select>
<!--注意: 💦label : 展示的是渲染到页面的数据  value:收集角色id,才是与rid绑定的值,所以动态绑定的rid拿到的是value的值💦-->
```



**rid :角色id    是接口里提供的参数**

##### 2.展示所有的角色列表   接口:1.4.8

```js
loadrolesList( ) {
// 注意:这个函数应该先在created里面调用一下

}

```

//把发送请求获取到的角色列表在data数据里保存一下

​     rolesList: [  ]

// 把发送请求拿到的数据赋值给rolesList

​      this.rolesList = res.data.data	

```js
async loadRolesList() {
      let res = await this.$axios.get('roles')
      console.log(res)
      // 把拿到的数据赋值给rolesList
      this.rolesList = res.data.data
    }
```

##### 在el-option标签里遍历所有的角色;v-for

label : 展示的item.rikeName

```js
<el-option v-for='item in rolesList' :key=item.id :label="item.roleName" :value="item.id"></el-option>
//注意:label : 展示的是渲染到页面的数据  value:收集角色id,是与rid绑定的值 是发送请求获取的id
//:label="item.roleName" 💦因为数据的动态的,所以前面加冒号
```



##### 3.展示自己当前的角色

- 给角色分配按钮注册点击事件@click = 'showAssignRoleDialog' ,

- 注意:这里在注册事件的时候就把@click = 'showAssignRoleDialog(scope.row) 传递过去,为后面获取里面的数据做铺垫;

- 当点击的时候弹出对话框展示的是当前点击的现有角色;

- 所以一开始对话框是默认隐藏的;

- ```js
  showAssignRoleDialog () {
      
        this.dialogAssignRoleVisible=true
  
  }
  ```



##### 4.提交给后台分配后的角色;





# day15

## 一.分配角色,usrs.html页面

#### 1.弹出对话框

注册@click='showAssignRoleDialog( )'

#### 2.显示所有的角色

#### 3.显示自己当前的角色

通过传值,拿到row (row里只能拿到username, id),rid需要通过1.3.4接口发送请求获取;

id  接口里的用户id

rid 接口里提供的角色id名:  

**注意**:接口1.3.4里根据用户id获取一个用户角色id

发送一个请求

```js
let res = await this.$axios.get('users/'+id)
//res数据里有要获取的rid
```

rid= -1,是没有分配过角色的清空

要求:如果没有分配角色,应该显示'请选择角色';

需要rid='' 空字符串;这里需要三元判断一下

```js
this.assignRoleForm.rid = res.data.data.rid===-1 ? '' :res.data.data.ridthis

```



#### 4.提交请求,分配新的角色

找到` 确定`按钮注册点击事件@click='startAssignRole';

发送请求,接口:1.3.7 put请求

```js
async startAssignRole() {
    
const {id,rid } = this.assignRoleForm
let res = await.....
判断===200 {
//关闭对话框
//提示
}
//刷新列表(如果要保留在修改的那页
    this.loadUsersList(this.pagenum)
}
}
```



## 二.解决问题:

### 1.点击对应的页码之后刷新继续保留在当前页users.js

思路:利用url地址刷新不会去除的特点,把页码作为参数放进去;

**路径==>页面(上->下)** 

需要修改成动态路由 , 在route.js里,接收参数,` path:'/users/:page?'`

**在users.js里获取url路径下的页码**

```js
//获取url路径下的页码
conconst curpage = this.$route.params.page
//console.log(curpage)
//获取到的是刷新之前所在的页码

💦在created函数里,加载页码是传入curpage
this.loadUsersList(curpage)
//这样就可以请求到之前刷新之前的页码对应的数据了;
```



**页面==>路径(下->上)**

在changePage( ) {  } 里面写

通过编程式导航跳转;

```js
// 🙃这里通过编程式导航跳转,解决点击页码刷新之后页码跳回默认的问题

   this.$route.push('/users/'+curPage)
```



## 三.左侧栏动态化(home.vue页面)

#### 1.要根据登陆的用户不同动态获取左侧栏的显示数据;

**接口:1.4.2  左侧菜单权限**

动态获取左侧权限loadMenus()

在钩子函数里一进页面调用一下

```
async loadMenus() {
let res = await this.$axios.get('menus')
...
}

```

注意:获取res之后,在data里预存一个空数组 menus:[ ]

- 1.在home.vue`el-submenu`里遍历;

```js
v-for='item1 in menus' :key='item1.id
```



- 2.数据里面还有自己的子元素children;再在`<el-menu-item> `遍历

```js
 v-for="item2 in item.children" :key="item2.id"
```

#### 2.解决关闭第一个菜单其他都跟着一起关闭的问题:

```
2.1 要保证第一层的index唯一;让index = 'item1.id';

	需要的是个字符串类型,所以index = 'item1.id+'' '

2.2 第二层的index也唯一

	:index=" '/'  +item2.path"

```



#### 3.高亮:解决刷新页码之后还保留在刷新之前页面的问题

在 ` <el-menu> `里设置样式

:default-active =' $route.path'



## 四.商品管理里面的商品分类

#### 1.创建一个组件Categories.vue

```
Categories.html页面

Categories.js页面

Categories.less页面

```



#### 2.路由的4步骤:

```
1.入口

2.规则

3.引入

4.出口

```



#### 3.商品数据列表 接口1.5.1,发送请求,获取页面数据

```js
 async loadCategoriesList () {
     //发送请求
      let res = await this.$axios.get('categories', {
        params: {
          type: 3,
          pagenum: 1,
          pagesize: 4
        }
      })
      console.log(res)
      this.catList = res.data.data.result
    }
```



Table 表格模板,放在一个div里

- el-table 的名字是      :data="catList" 

- label="是否有效",prop="cat_deleted" ;是否有效:获取到的值是true/false  布尔类型的,不能正常赋值,需要借助自定义列处理;

```js
 #是否有效,先写个template标签,再在里面写span标签;
<el-table-column prop="cat_deleted" label="是否有效" width="180">
    <template slot-scope="scope">
        <span>{{ scope.row.cat_deleted ? '否' : '是' }}</span>
    </template>
</el-table-column>
```



#### 4.添加分类按钮

一个<` el-button type='success' plain>`按钮就可以了

#### 5.点击左侧箭头有显示三级目录

🙃**5.1需要用到一个插件:element-tree-grid**

安装:npm install element-tree-grid --save 

引入:放在main.js里   import.....

全局注册:放在main.js里

```js
// 引入+注册
import ElTreeGrid from 'element-tree-grid';
Vue.component(ElTreeGrid.name, ElTreeGrid);
```



拷贝模板` el-table-tree-column`

```js
//模板
<el-table-tree-column
  file-icon="icon icon-file" //箭头
  folder-icon="icon icon-folder" //表示是文件夹的形式
  prop="cat_name"
  label="分类名称"
  width="220">

</el-table-tree-column>
```

prop='cat_name'

label='分类名称'

把事件的分类名称列注释掉,因为模板里有可以代替的;

##### 5.2解决点击箭头展开的时候显示的位置在当前点击父元素的下面的问题;

```js
添加几个属性:在el-table-tree-column标签里

1. treeKey属性:     tree-key=' cat_id' =>使用这个可以去找准自己的子节点的

2. parentKey属性:     parent-key=' cat_pid'   => 这个能够找准自己的父节点

3. levelKey属性:     level_key = 'cat_level'  =>根据层级进行适当的缩进

4. indenttSize属性:    :indentt-size='30'; (30需要的个数字类型) => 再次缩进30px的距离;

#注意:
因为30需要的是个数字类型,所以前面加个冒号

```



## 6.添加分类

```js
1.点击添加分类按钮,注册点击事件,点击显示一个对话框;
@click='showAddCatVisible',显示添加分类弹框
:visible.sync='dialogAddCatVisible'

2.对话框的模板 ==>dialog对话框==>自定义内容
<el-dialog :visible.sync="dialogAddCatVisible">
<el-form :model="addCatForm">

#3.级联选择器Cascader  
element组件里有:参考Cascader级联选择器==>选择即改变;
​```
<el-cascader
  v-model="addCatForm.cat_pid_arr"
  :options="options"  //可选项数据源,是数组类型
  change-on-select
  :props="defaulProps"  //配置选项
</el-cascader>
​```
-分析模板:
change-on-select选择即改变
#参数 :options="options" 可选项数据源;键名可通过 props 属性配置;是数组类型;

#注意:
把el-cascader模板加在el-form-item 标签里;
级联选择器数据options 放在data里,是一个数组;

#接口:1.5.2  
分类名称: cata_name 
-所以<input>标签上v-model="addCatForm.cata_name";

-给级联选择器<el-cascader>上也绑定一个v-model='addCatForm.cat_pid_arr'; cat_pid_arr是自定义的,到时候存的是一个*数组*;
-把双向绑定的两个名称放在data数据里的表单对象里
​```
// 添加分类表单对象
      addCatForm: {
        cat_name: '',
        cat_pid_arr: []
      },
​```


```



```js
获取分类列表数据(2)级   
接口1.5.1

#因为之前已经获取过3级列表数据
// 获取分类列表数据 (3级)
​```
    async loadCategoriesList () {
      let res = await this.$axios.get('categories', {
        params: {
          type: 3,  // 3级数据
          pagenum: 1,  //第一页数据
          pagesize: 4  //每页4条数据
        }
      })
      console.log(res)
      this.catList = res.data.data.result
    }
​```

//再获取一次2级列表数据
​```
  // 获取分类列表数据 (2级)
    async loadCategoriesList2 () {
      let res = await this.$axios.get('categories', {
        params: {
          type: 2
        }
      })
      console.log(res)
      this.options = res.data.data
    }
​```		
#注意:
这里把真实数据赋值给option之后,出现了有结构,没有显示文字的情况;
#解决办法:
-默认情况下:
label:负责显示标题
children 负责结构
value 负责收集数据;

-真实情况下:
#配置项需要根据数据做出修改:
js里,
defaulProps:{
label: cat_name 负责显示标题
children: children 负责结构
value: cart_id  负责收集数据
}
#props参数:见参考
#在html里,:props="defaulProps"前面加冒号是因为它是一个对象,加冒号可以拿到它本来的类型,不加则拿到的是一个字符串;

-给确定按钮注册点击事件@click='startAddCat'
发送请求
父类父id:
cate_name
层级=数组的长度:
===201
关闭对话框
刷新列表

```

🙃🙃🙃🙃🙃🙃🙃🙃🙃🙃🙃🙃🙃🙃

### 商品列表  

#### 创建商品组件goods.vue

找表格模板结构放入template;

商品列表   接口1.6.1

js里 goodList:[  ]



```js
async loadGoodsList () {
    //发送请求  query,pagenum,pagesize都是接口里提供的参数
      let res = await this.$axios('goods', {
        params: {
          query: '',
          pagenum: 1,
          pagesize: 4
        }
      })
      console.log(res)
      this.goodsList = res.data.data.goods
    }
// 在钩子函数里调用一下
```



#### 时间戳,使用自定义列

创建时间需要引入自定义列,**使用过滤器处理,过滤器管道**

```js
# html页面:
用template标签包裹一个span标签;
` <span>{{scope.row.add_time | dateFilter}}</span> `

​```js里
filters: {
    dateFilter (res) {
      return moment(res).format('YYYY-MM-DD hh:mm:ss')
    }
  }
​```

-需要安装moment : npm i moment

-引入在js:  import moment from "moment"; 

```



### 添加商品页面goods-add 

```js
#  1.点击添加商品按钮跳转到goods-add页面;
-添加商品按钮注册点击事件@click="$router.push('/goods-add')";

2.创建组建份模块化goodsAdd.html , goodsAdd.vue , goodsAdd.js , goodsAdd.less

3.  4个步骤
4.  element插件找steps步骤条模板
	:active="activeStep"   高亮的步骤
    
​```html
<el-steps :active="active" finish-status="success">
    <el-step title="第一步" description="基本信息"></el-step>
    <el-step title="第二步" description="商品图片"></el-step>
    <el-step title="第三步" description="商品内容"></el-step>
 </el-steps>
​```
    
5.标签页
```

#### 标签页

```js
1.找模板element ==>Tabs 标签页  ==>位置

-组件的位置有四个方向都可以选择;  <el-tabs tabPosition="left/right/top/bottom">
    
-组件提供的事件tab-click,tab被选中时候触发,回调参数是被选中的标签 tab 实例;


```



#### 步骤条和标签页关联起来

```js
1-点击标签页切换对应的步骤条的步骤;
2-通过点击标签页来控制activeStep的改变达到关联改变的目的;data数据里的activeStep默认等于1;

3-@tab-click="clickTabs"点击标签页的时候就会触发的事件;
-🙃tabs事件:组件提供的事件tab-click,tab被选中时候触发,`回调参数`是被选中的标签 tab 实例;
​```
clickTabs (el) {
	// console.log(el.index)
     // 里面有个index0.1.2 与步骤条的步骤可以关联,所以把他可以赋值给activeStep ;
	//这里拿到的index是字符串,需要转化成数字;
      this.activeStep = +el.index + 1    
 }
​```
4-给每个el-tab-pane设置个别名 name=' one/two/three '控制标签页;
```



#### 添加商品==>基本信息页面

```js
// html里:
<el-form ref="goodsAddForm" :model="goodsAddForm" label-width="80px">
    
#接口:1.6.2
-根据接口里的参数名把html里的名称修改一下;
-发送请求,把输入的数据收集并且提交到后台;
```



```js
-商品分类:3级级联选择器

-获取所有的分类数据并且赋值给options;

// 获取所有的分类
async loadCatList () {
//发送请求  接口:1.5.1
        
   let res = await this.$axios.get('categories', {
        params: {
          type: 3
        }
      })
      console.log(res.data.data)
      //把res赋值给options
      this.options = res.data.data
    }

注意:配置项要跟后台参数对应;这样才能结构和数据一起显示;
在html里<el-cascader>标签上加:props="defaultProps"
```

```js
-是否促销;

-单选框组件模板;

​```
<el-form-item label="是否促销">
   <template>
     <el-radio v-model="goodsAddForm.goods_isPromotion" :label="true">是</el-radio>
      <el-radio v-model="goodsAddForm.goods_isPromotion" :label="false">否</el-radio>
    </template>
 </el-form-item>
​```

v-model= 'goods_isPromotion'
:label='true / fasle'

#注意:
单选框特殊的地方:label的值不再负责展示,而是收集;
跟2级3级联动相反;


```



# day16

### 商品列表页面的添加上传图片

组件库==>upload上传==>照片墙

`<el-upload>` 

` <el-dialog>`里面是起到预览功能的代码

接口 1.7

拷贝上传图片事件方法;

```js

	//data数据 上传图片部分
      dialogImageUrl: '',
      dialogVisible: false

	// 上传图片部分js
    handleRemove (file, fileList) {
      console.log(file, fileList)
    },
    handlePictureCardPreview (file) {
      this.dialogImageUrl = file.url
      this.dialogVisible = true
    }
```



如果要把+换成上传图片文字,把i标签修改成button;

**action='基路径' +接口路径;**

模板里提供的参数:

| **on-preview** | **点击文件列表中已上传的文件时调用的函数** |
| -------------- | ------------------------------------------ |
| **on-remove**  | **文件列表移除文件时调用的函数**           |
| **on-success** | **文件上传成功时调用的函数**               |
| action         | 必选参数，上传的地址                       |
| 🙃headers       | 设置上传的请求头部(要求是个对象)           |

##### 

#### 🙃图片上传步骤解析:

##### **把图片第一次上传给服务器,服务器返回给一个地址,我们把这个地址和其他的商品名称,价格 ,描述等等goodsAddForm [ ] 里的数据一起作为一个整体一起 再上传到服务器;**

在html里   ` <el-upload> `  加上  :on-success=' uploadSuccess'  

**在js里,执行函数当图片上传成功时的函数**

```js
uploadSuccess (res) {
   🙃//console.log(res)  此时会打印'无效的token'
}
# 添加请求头
所以,这里需要手动加一个请求头 token,在html的<el-upload>标签的属性上 加上 :headers="headers"
并且在data数据里写上
​```
headers: {
    Authorization: localStorage.getItem('token')
}
​```
```



#### 获取上传图片的地址:

```js
#接口1.6.2
- 参数:   pics  上传图片的临时路径

- 获取到的路径:

#tmp_path:临时路径

"tmp_uploads\c66c50a8f513eca969e45c1a9efbc225.jpg"

#url: url路径

"http://47.96.21.88:8888/tmp_uploads\c66c50a8f513eca969e45c1a9efbc225.jpg"

工作中.图片的地址使用url  现在使用临时路径是因为我们用的是本地服务器;

​```
在goodsAddForm:{

	里面加一个pics:[ ]

}
​```
```



##### 

```js
在上传图片成功的回调里,上传的临时图片路径需要是一个对象
uploadSuccess (res) {
   console.log(res.data.tmp_path)
   // 把这个临时路径设置给goodsAddForm
   this.goodsAddForm.pics.push({
       pic: res.data.tmp_path
   })
}
```

**图片下的文字是个p标签**

### 商品列表页面的图片内容页面

```js
插件:富文本编辑器插件,网址:https://github.com/surmon-china/vue-quill-editor
在github里面vue-quill-editor

1.安装:npm install vue-quill-editor --save
2.引入:
	在js里还要引入css;
```
	import 'quill/dist/quill.core.css'
	import 'quill/dist/quill.snow.css'
	import 'quill/dist/quill.bubble.css'
	```
	引入组件模块
	import { quillEditor } from 'vue-quill-editor'

3.还需要注册一下;
​```
	export default {
  		components: {
    	quillEditor
  		}
	}
​```

```

**使用:**

**SPA单页面应用里是使用的方法:**

##### **接口1.6.2**

参数: goods_introduce  介绍

**文本编辑器代码说明:**

v-model="goodsAddForm.goods_introduce" 双向数据绑定;**

:options="editorOption"   设置项,可以设置占位符等;

在data数据里设置富文本配置项

​```js
editorOption: {
   placeholder: '哈哈'
},
 htmlStr: `<h1 class='red'>我是h1</h1>`
```

**给富文本设置颜色和高度;**

```js

```

​			



##### **这里有一个加了样式不生效的问题:**

```js
给编辑器加了宽高等样式,在页面中设置样式是ok的,在less里面设置样式就不生效的问题;
原因是scoped:
```



#### scoped

```js
作用:
1.添加了scoped属性,当前组件内的样式,只能在当前组件内使用;
2.scoped对动态添加的组件显示是有问题的;
```



**富文本编辑器和v-html都是属于动态添加的;**

#### 解决方式:

```js
#方式1:

 删除style标签上的scoped(不推荐)

#方式2:

 把动态添加的样式剪切提出来,重新建一个style标签,不加scoped;

#方式3:穿透

 /deep/ 穿透;  找一个 父元素/deep/子元素(子元素是动态的)

因为子元素的动态的,找到的父元素不能是动态;.

.father /deep/ .red {

	...样式

}
#方式4:

不能用在less的后缀文件里,可以用在css里,修改文件后缀名为css

.father  >>>  .red {

	...样式
	
}


```



#### **添加按钮**

```js
 // 点击添加按钮添加商品
    async addGoods() {
      const {
        goods_name,
        goods_price,
        goods_weight,
        goods_number,
        goods_cat,
        goods_isPromotion,
        pics,
        goods_introduce
      } = this.goodsAddForm
      
      //发送请求
      let res = await this.$axios.post('goods', {
        goods_name,
        goods_price,
        goods_weight,
        goods_number,
        goods_cat :  goods_cat.join(',')  ,
        goods_isPromotion,
        pics,
        goods_introduce
      })
      console.log(res);
        //判断
      if (res.data.meta.status === 201) {
		//提示
        this.$message({
          message: '添加商品成功',
          type : 'success'
        })
		// 跳转
        this.$router.push('/goods')

      }

    }
注意:ql-container是富文本编辑器里动态的类名;
```





### **打包**

#### **方法:npm run build**

##### **打包完之后在控制台显示的内容分析:**

```js
#第一次打包分析
- vendor 显示big   第三方包,表示内容有点大;
- manifest  处理模块之间的逻辑关系
- app  样式

- .map  内部查找用的,遍历映射

- app入口,包括代码,组件,就是源码里面的main.js ==>引入了路由 ==>路由里又引入了所以的组件(登陆,ho0me,users.等等)
  一打开页面,只能看到login首屏(login);
  首屏时间:就是打开看到首屏所需要的时间,时间越少越好;
  首屏时间体现网页性能时间的好坏;
  现在是把所有的组件都加载进来放在了app里面,这样会延迟首屏显示时间,所以需要分割成需要哪个加载哪个的形式;
   分割:在vue文件里==>路由懒加载
  使用:异步组件在router.js里
  分割方法(注意:首屏不分割)
  const Foo = () => import( ' ./Foo.vue
   ' )
  分割之后再打个包 npm run build
  

```



```js
#第二次打包分析

异步组件显示0-6.....js

按需加载:

打开powershell窗口;模仿一个http-sever,测试一下:控制台=>network 访问哪个页码此时就才加载哪个模块 看显示的带序号的数字,对应刚刚的0-6

-endor第二次打包显示还是big   

-vendor:打的是本地的包,使用一个在线的包vendor才会越来越小



```



#### **CDN 在线的包**

**使用:**

1.引入在线的包CDN  

**https://cdn.jsdelivr.net/npm/vue@2.5.2/dist/vue.min.js**

**🙃在index.html中 引入vue**

**`<script src='https://cdn.jsdelivr.net/npm/vue@2.5.2/dist/vue.min.js'></script>`**

**2.配置:**

**在build/webpack/base/config.js中末尾添加配置cdn**

```js
externals:{
   //键: 值
   //包名:全局变量
//引入vue
   vue:'Vue'
//引入router
   'vue-router:'VueRouter'
 //引入element
    
}

```

```js
#第三次打包

以前:775kb   现在681kb

引入路由

在index.html里

<script src='...'></script>

引入element

在index.html里

<script src='...'></script>

<link>引入css

如果引入了css记得把项目当时的css注释掉,不然会重复本地打包

此时再打包:

现在47.2kb

```





#### **bootCDN地址在哪里找到?**

```js
#方式1.
在bootstrap网站下面旗下网站可以找到;
#方式2.
或者也可以在官网找;

```



##### **打包后访问方法:**

```js
开启一个虚拟的服务器  http-server
```



# **vuex**

### **1.介绍**

**是状态管理工具;**

**状态即数据,管理data里的数据;**

**vuex 采用的**

**把需要共享的数据放到vuex里管理**





##### **什么时候用vuex技术栈?**

```
如果需要构建一个中大型的项目,可以使用vuex
```

##### **vuex的基本使用**

```js
1.安装:npm i vuex;
2.引入<scripe src=''>
#注意:vuex/router都是依赖vue的,要先安装,引入vue
3.实例化仓库(操作数据都要经过store)
const store = new Vuex.store({
 //状态:相当于之前vue里的data
    state:{
       num:100 
    }
})


```



**注意:直接获取和修改是没有问题的;但是..vuex和js一样,有一个严格模式;**

**所以有另一个修改数据的方法:**

```js

```



##### **vuex的传参**

```

```



##### **vuex和vue的配合使用**

```
store也需要挂载在vue 实例上
```



### **todos**

**初始化vue init webpack vuex todos**